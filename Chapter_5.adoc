:toc:
:toclevels: 4
:imagesdir: ./

== Chapter 5. Interfaces, Lambdas, and Anonymous Classes

In this chapter I'll focus on discussing how you can program _behavior_ in Java.  Classes have attributes (e.g. color, number of doors) and exhibit behavior (e.g. eat, sleep, or dive). There is a special group of programming languages that are called _functional_ (e.g. JavaScript, Scala et al.) In these languages you can simply write functions like `eat()`, `sleep()`, or `dive()`, and these functions can live their independent lives and don't have to be declared in classes. In _object-oriented_ languages behavior is implemented in methods defined in classes. Starting from Java 8 you can also program behavior in so called _lambda expressions_ covered later in this chapter. 

So far I was declaring and implementing behavior in methods located inside Java classes. But there is a way and a reason to separate the method declaration from its implementation. Such separation can be done using _interfaces_.

=== Java Interfaces

For years, Java _interfaces_ were used mainly for holding just method declarations and final static variables. For example, the interface `Talkable` can just contain the declaration of the method `talk()`:

[source, java]
----
interface Talkable{
	public void talk();
}
----

Since the method `talk()` is not implemented here, it's called _abstract_. 

NOTE: To create a new interface in IDEA, select the menu File | New | Java class and select Interface in the Kind box.

[[FIG5-1]]
.Creating an interface in IDEA
image::images/fig_5_01.png[]

You should be thinking, "What's the point of simply declaring a method without implementing it?" The thing is that more than one class can exhibit the same behavior. For example, a dog, a cat, and a parrot can "talk". But they "implement it" differently. A parrot can repeat words, while dogs bark. Cats talk by meowing. Accordingly you can declare three classes that will _implement_ `Talkative` interface differently, as shown below:

[source, java]
----
public class Parrot implements Talkative {
    public void talk(){
        System.out.println("My name is Kesha.");
    }
}

public class Dog implements Talkative {
    public void talk(){
        System.out.println("Bark! Bark-bark!");
    }
}

public class Cat implements Talkative {
    public void talk(){
        System.out.println("Meow! Meow!");
    }
}
----

These three classes use the Java keyword `implements`, which means they promise to implement all abstract methods in the interface(s) listed after the keyword `implements` otherwise the Java compiler will complain: "You promised to implement all abstract methods from `Talkable`, where are they? Keep the promise!" 

What if we need to create the class `Fish` that uses interfaces? Fish don't talk. But they swim. Dogs can talk and swim, right?  Why won't we declare yet another interface `Swimmable` with the methods `swim()` and `dive()`?

[source, java]
----
public interface Swimmable {

    public void swim(int howFar);

    public void dive(int howDeep);
}
----

Now let's leave the parrots alone. Let's create a new class `Fish` and change the class `Dog` just a little bit. The `Fish` will implement `Swimmable` and the `Dog` will implement two interfaces:

[source, java]
----
public class Fish implements Swimmable {
    public void swim(int howFar){
        System.out.println("OK, will swim " + howFar + " feet");
    }
    public void dive(int howDeep){
        System.out.println("OK, will dive " + howDeep + " feet");
    }
}

public class Dog implements Talkative, Swimmable {
    public void talk(){
        System.out.println("Bark! Bark-bark!");
    }

    public void swim(int howFar){
        System.out.println("Will swim about a half of this distance: " + howFar/2 + " feet");
    }

    public void dive(int howDeep){
        System.out.println("C'mon, don't ask a dog to dive, please!");
    }
}
----

When a class implements several interfaces, make sure to implement each and every abstract method declared in these interfaces. I'll tell you more: a class can extend another class and implement interfaces at the same time, for example:

[source, java]
----
class Fish extends Pet implements Swimmable{
  
  // your code implementing swim(), dive() 
  // and any other methods goes here
}
----

NOTE: Java includes several interfaces that don't declare any methods (e.g. `Serializable). They are called _marker interfaces_. You don't need to implement any methods in classes that implement marker interfaces. They are used by the Java compiler internally to generate the byte code in a special way.

==== Default Methods in Interfaces

To tell you the truth, I don't like the fact that I had to implement the method `dive()` in the class `Dog`. The dogs I've seen can't dive. Can the interface `Swimmable` be changed so I'm not forced to write the implementation of the method `dive()` in the class `Dog`? Yes, it can. Java 8 introduced a new keyword `default`. Now you're allowed to write a default implementation of a method in the interface. Such a method won't be considered abstract anymore, and you won't be forced to implement it in your class. Let's add a default implementation of the method `dive()` to `Swimmable`.

[source, java]
----
public interface Swimmable {

    public void swim(int howFar);

    public default void dive(int howDeep){
        System.out.println("Can't dive, sorry");
    };
}    
----

Now the class `Dog` doesn't have to implement the method `dive()` - the compiler will see a default implementation and won't complain. The next version of the class `Dog` implements only the method `swim()` from `Swimmable`.

[source, java]
----
public class Dog implements Talkative, Swimmable {
    public void talk(){
        System.out.println("Bark! Bark-bark!");
    }

    public void swim(int howFar){
        System.out.println("Will swim about a half of this distance: " + howFar/2 + " feet");
    }
}
----

There is no need to change the class `Fish`. It also implements `Swimmable`, but has its own version of the method `dive()`, which will override the default implementation of the `dive()` from `Swimmable`. You can still call the method `dive()` on the instance of the `Dog` class - the default implementation will be invoked. The next class `PetMaster` will demonstrate this.

[source, java]
----
public class PetMaster {
    public static void main(String[] args) {

        Dog myDog = new Dog();
        myDog.talk();
        myDog.swim(7);
        myDog.dive(2);  // will use default method

        Fish myFish = new Fish();
        myFish.swim(50);
        myFish.dive(20);
    }
}
----
Run this program and you'll see the following output on the console:

[source, java]
----
_Bark! Bark-bark!
Will swim about a half of this distance: 3 feet
Can't dive, sorry
OK, will swim 50 feet
OK, will dive 20 feet
----

The message "Can't dive, sorry" was printed by the default method `dive()` from the interface `Swimmable`.

==== Static Methods in Interfaces

Starting from Java 8, interfaces are also allowed to include static methods, which are not specific to any instance and can be used only internally by other methods of the interface. The following example illustrates the use of a static method in the interface. Now the default implementation of the method `dive()` won't just reject an offer to swim, but will check the current month: if it's June, July, or August then diving is allowed because the water should be warm. 

The modified version of the `Swimmable` interface includes a static method `isSummer()` that checks the current month and returns `true` if it's June, July, or August. I'm using the Java Date and Time API here. The default method `dive()` calls the static method `isSummer()` and either agrees or disagrees to dive depending on the time of the year.

[source, java]
----
import java.time.LocalDate;
import java.time.Month;

public interface Swimmable {

    public void swim(int howFar);

    public default void dive(int howDeep){

        if (isSummer()){
            System.out.println("OK, will dive. The water should be warm.");
        } else {
            System.out.println("Can't dive, sorry. The water's cold for diving.");
        }
    };

    // Check if it's summer now
     static boolean isSummer(){
        Month month = LocalDate.now().getMonth();
        if (month == Month.JUNE || month == Month.JULY || month == Month.AUGUST){
            return true;
        } else{
            return false;
        }
    }
}
----

The method `isSummer()` uses the class `LocalTime` to get `Month`, which has a data type `enum` that I haven't used so far. It's a special data type to represent a fixed number of some values, like months in this case. There are only 12 months, and Java Date and Time API listed them by name in the `enum` called `Month`. The only values that are allowed here are `Month.JANUARY` to `Month.DECEMBER`. Using enums makes the programs more readable - it's easier to deal with months by names than by numbers.

.Packages and import statements
*******************************
Java comes with many useful classes that are organized in packages. Some packages include classes responsible for drawing, while other packages have classes to work with the Internet, and so on. For example the class `LocalDate` is located in the package called `java.time`, and the full name of the class `LocalDate` is `java.time.LocalDate`.  

To let the compiler know where the class `LocalDate` is located you could specify the full class name, for example:

[source, java]
----
java.time.LocalDate todaysDate = java.time.LocalDate.now();
----

But this syntax is difficult to read so we use the `import` statements above the class declaration to let the compiler know the location of the class, interface, or enumeration. For example:

[source, java]
----
import java.time.LocalDate;
----

Now you can use just the class name without the need to specify the package name:

[source, java]
----
LocalDate todaysDate = LocalDate.now();
---- 

The packages are stored in directories and subdirectories on the disk. If you see a full class name `java.time.LocalDate` it means that this class was originally created in the subdirectory _time_ of the directory _java_. 

From now on we'll use packages and import statement in every chapter of this book. If you want to place your class into a package, just create a subdirectory (e.g. _pets_) and add a `package` statement on the top of your class definition, for example:

[source, java]
----
package pets;

class Dog{
	// your code goes here
}

---- 

One last thing: Lazy kids use the wild cards in import statements. Instead of writing one import statement per class, they would use an asterisk:

[source, java]
----
import java.time.*;
----

This means that definitions needed for my program are located in the package `java.time`. Of course, writing one import statement instead of several ones looks appealing, but the readability of the program suffers. Packages can have dozens of classes and it's better to explicitly state which classes your program uses.  


*******************************

==== Final Static Variables in Interfaces

Beside method declarations, default and static methods you can add `static final` variables to the interface declaration.  Such variables can be used by the code inside the interface or in the classes that implements it. For example, the interface `Swimmable` can define the maximum depth allowed for diving. Here's yet another version of the interface `Swimmable`:

[source, java]
----
public interface Swimmable {
    
    static final MAX_DEPTH = 10; // in feet

    public void swim(int howFar);

    public default void dive(int howDeep){
        if (howDeep > MAX_DEPTH){
           System.out.println("Can't dive, sorry");
        }
    };
}    
----

A class that implements `Swimmable` can use the value of `MAX_DEPTH` too.

==== Functional Interfaces

If an interface has only one abstract method declared (default and static methods don't count) it's called _functional interface_. Both `Talkative` and `Swimmable` are  examples of a functional interface - each has only one abstract method. Java 8 introduced a special way of implementing functional interfaces using lambda expressions, which we'll discuss next. 

=== Anonymous Classes

If you need to use an object of certain type only once, you can kill two birds with one stone: declare an anonymous class and create an instance of it. In this case you don't even need to give a class a name, hence it's _anonymous_.

Usually, anonymous classes are presented in the context of event processing in the programs that have In Chapter 7 you'll learn how to create a Graphical User Interface (GUI), and I'll show you how you could use an anonymous class there too. But for now I'll show you another example of a program that's first written without and then with anonymous classes. 
Let's say I want to write a simple calculator in Java. It won't have any GUI, but I'll show you how you can you can program such operations as addition and subtraction. The multiplication and division operations can be programmed  similarly, so I won't be implementing these operations. 

I want to keep these examples in the package called `calc`. As I said earlier, you can create a subdirectory named _calc_ in your project and save your classes there. The other choice is to right-click on the folder _src_ in your IDEA project and select the menu New | Package and enter the package name: 

[[FIG5-2]]
.Creating a new package in IDEA
image::images/fig_5_02.png[]

First comes the version that doesn't use anonymous classes - I'll just use one method for each operation. The code of the class `Calculator` is pretty simple. Note the first line that declares the package where the class `Calculator` belongs.

[source, java]
----
package calc;

public class Calculator {

 static double addTwoNumbers (double first, double second){
     double result = first + second;
     System.out.println("" + first + " + " +
                       second + " = " + result  );
     return result;
 }

 static double subtractTwoNumbers (double first, double second){
     double result = first - second;
     System.out.println("" + first + " - " +
             second + " = " + result  );
     return result;
 }

 }

 public static void main(String[] args) {

     addTwoNumbers(3.55, 50.00);
     subtractTwoNumbers(3.55, 50.00);
 }
}
---- 

This class has two methods that manipulate numbers (one per operation), and its `main()` method invokes each method  passing the same values as arguments. Running this program prints the following on the console:

[source,java]
----
3.55 + 50.0 = 53.55
3.55 - 50.0 = -46.45
----

Now let's redesign this application. I want to write a method that will have three arguments: the arithmetic operation and the first and the second numbers to be operated upon. 

The operation is a behavior, so let's declare an interface to represent it. This will be a functional interface with a single abstract method:

[source, java]
----
package calc;

public interface ArithmeticOperation {

  public double performOperation(double a, double b);
}
----

I'll write two implementations of the `ArithmeticOperation` interface using anonymous classes - one for addition and one for subtraction. I will also write a method `calculate()`   that will take three arguments: the object that implements `ArithmeticOperation` and knows how to manipulate the numbers; other arguments are two numbers to be manipulated.

[source, java]
----
package calc;

public class CalculatorWithAnonymousClasses {

    // Anonymous class one
    static ArithmeticOperation addition = new ArithmeticOperation() {
        public double performOperation(double first, double second) {
            double result = first + second;
            System.out.println("" + first + " * " +
                    second + " = " + result );
            return result;
        }
    };

    // Anonymous class two 
    static ArithmeticOperation subtraction = new ArithmeticOperation() {
        public double performOperation(double first, double second) {
            double result = first - second;
            System.out.println("" + first + " - " +
                    second + " = " + result );
            return result;
        }
    };

    // This method performs a given arithmetic operation on the provided numbers
    // The first argument is an instance of the anonymous 
    // class that implements ArithmeticOperation
    
    public static double calculate(ArithmeticOperation whatToDo, double a, double b ){

        return whatToDo.performOperation(a,b);
    }

    public static void main(String[] args) {

        calculate(addition, 3.55, 50.00);
        calculate(subtraction, 3.55, 50.00);
    }
}
----

The output of the `CalculatorWithAnonymousClasses` program will be the same as from `Calculator`. What did we achieve by re-writing calculator this way? We separad the declaration of the behavior and its implementation.  The behavior is declared in the interface, and if more than one class would need to implement `ArithmeticOperation`, we'll reuse this interface. The anonymous classes allowed me to create a wrapper object around the method `performOperation()`, so this object could be passes as an argument to the method `calculate()`. In the next section I'll re-implement this calculator in a more elegant way with lambda expressions.


=== Lambda Expressions

Up till now, to invoke a method we've been creating classes and instantiating objects. But lambda expressions allow to define and invoke a piece of code even without the need to write a method wrapped it into a class.

A lambda expression is an anonymous function that you can assign to a variable, pass as an argument to a method or return from a method. In earlier versions of Java only you could pass a value to a method only if this value is an object or a primitive. But now a function (a piece of code) to execute becomes a value that can be passed around. I'll explain what all this means by example.
  
Prior to Java 8, to represent an operation we'd need to wrap it as a method inside the Java object. With lambda expressions, you don't need to create wrapper classes.  

Now I'll write yet another version of the calculator to replace the anonymous classes with shorter lambdas. This time I'll declare each arithmetic operation as a lambda expression. I will use the same method `calcuate()` that will take three arguments: the lambda expression that implements `ArithmeticOperation` and two numbers to be operated on.   

[source, java]
----
public class CalculatorWithLambdas {

    // Declaring lambda expressions
    static ArithmeticOperation addition = (first, second) -> {
        double result = first + second;
        System.out.println("" + first + " + " +
                second + " = " + result );
        return result;
    };

    static ArithmeticOperation subtraction = (first, second) -> {
        double result = first - second;
        System.out.println("" + first + " - " +
                second + " = " + result );
        return result;
    };

    // This method performs a given arithmetic operation on the provided numbers
    // The first argument can be implemented as lambda expression
    
    public static double calculate(ArithmeticOperation whatToDo, double a, double b ){

        return whatToDo.performOperation(a,b);
    }

    public static void main(String[] args) {

        calculate(addition, 3.55, 50.00);
        calculate(subtraction, 3.55, 50.00);
    }
}
----

The difference between `CalculatorWithAnonymousClasses` fro previous section and `CalculatorWithLambdas` is that the former implements the functional interface as anonymous classes and the latter as lambdas. Lambda expressions offer a concise way of implementation of functional interfaces.   

NOTE: IntelliJ IDEA can automatically convert anonymous classes that implement functional interfaces into lambda expressions. Just make sure to visit the menu File | Project Structure and select the project language level to be 8.0.


== Challenge Yourself

Part 1. In this part you'll do an exercise to prove that you understand Java interfaces. 

1. Create a new IDEA project

2. Recreate the final from versions of classes `Dog`, `Fish` and interfaces `Swimmable` and `Talkable` from the section Interfaces.

3. Create a new class `Pet` with a constructor that will take a name of the pet (a `String`) as an argument.

4. Change the declarations of the classes `Dog` and `Fish` so each of them extends `Pet` while implementing `Talkable` and `Swimable` interfaces.

5. Create the class `PetMaster` from the section Interfaces, but give pets names while instantiating `Dog` and `Fish`.

6. Modify implementations of the methods `talk()` and `swim()` so they would print the pet's name as a part of the output in `System.out.println()`.

7. Run and test `PetMaster`. 

Part 2. In this part you'll do an exercise to prove that you understand Java lambda expressions.