:toc-placement!:
:imagesdir: ./

== Chapter 8. Programming User Interaction in JavaFX

After the GUI design is done, we need hook it up with the  application code written in Java. The Sign In and calculator window windows from Chapter 7 looks good, but none of them would react on user's actions. No matter how hard you click on the Sign In or calculator's buttons, nothing will happen because we didn't teach these application how to react on user-generated events (e.g. button clicks). 

Events are notifications that something important for the application has happened. In this chapter you'll learn what kind of events may happen in a JavaFX application and how to write code to handle these events.  The generated class`Controller` is empty as of yet, but we'll add some code to it to communicate with the GUI components.  


=== Events

JavaFX applications have to deal with various events. For example, a button click, a mouse move etc. An event object is represented by the instance of the class `Event` located in the packages `javafx.event` and `javafx.scene.input`. You'll always write event handlers (a.k.a. event listeners) in Java, but there are different ways of assigning event handlers to GUI elements. If your GUI is designed with FXML, you'll need to specify the name of your controller class right in the FXML file. 

[[FIG8-1-0]]
.Event listeners 
image::images/fig_8-01-1.png[]

You can either create with `new` or _inject_ an instance of your controller class into Java code. I'll explain you what injection means in a bit. 

==== Assigning Event Handlers in FXML

Scene Builder allows you not only to design and arrange the GUI components on the scene, but also assign the Java code that will be handing events. We'll stick to our principles of separating GUI and application logic, and will keep the GUI in .fxml file, but processing in Java. 

In Scene Builder you may have noticed the _Controller_ bar in the bottom left corner. This is the place were you can specify a Java class that will contain event handling code and may use other classes implementing application logic.

At the bottom right corner of Scene Builder you may notice a tab titled Code. This is where you can assign event handler methods to selected GUI component after assigning the controller class. So you could select have selected, say a button in the central canvas and assign its click handler right in the _Code_ section for this button. 


=== Hooking up a Controller to GUI

Since we're separating the GUI code form the application logic, we need a way to specify that a particular FXML file should use a particular controller. In Chapter 7 I didn't bring your attention to where it's done in FXML, but if you'll look at any of the FXML files, you'll see that the name of the controller was specified there when IDEA generated the project for us. 

==== Adding Controller to Sign In application

To illustrate the use of controllers, I'll continue working on the sample Sign In project from Chapter 7. It has a file signin.fxml that includes the following `GridPane` tag:

[source, xml]
----
<GridPane hgap="10" vgap="10" 
    xmlns="http://javafx.com/javafx/8" xmlns:fx="http://javafx.com/fxml/1" fx:controller="signin.Controller">
----

The `hgap` and `vgap` attributes specify the padding between the grid grid columns and rows. The `xmlns` attributes specify so called namespaces required for proper parsing of FXML files. And the attribute `fx:controller` specifies the full name of the class `Controller`, which in our project is located in the package `signin`. 

When the file signin.fxml is loaded, JavaFX runtime creates an instance of the class `signin.Controller` and injects it in the instance of the GUI class generated from FXML. The word injection describes the situation when a runtime automatically instantiate a class B and make it available in class A. For us it means that there is no  need to create an instance of the `signin.Controller` manually by using the `new` operator. 

The first version of our controller class is shown next: 

[source, java]
----
package signin;

import javafx.event.ActionEvent;

public class Controller {

  public void signInClicked(ActionEvent evt){

    System.out.println("Hello from signInClicked method in controller");  
  }
}
----

The class `Controller` uses the class `ActionEvent` from package `javafx.event`, and I want to warn you - be careful when IDE will offer you help in insert an import statement for you. There is also an `ActionEvent` in the package `java.awt.event`, which we don't want in this case.

We want the method `signInClicked` to be called on the controller if the user clicks on the button. For this to happen, we need to specify the name of this method as a handler of the `onAction` event in the Button element in signin.fxml as shown on Figure 8-1.

[[FIG8-1]]
.Mapping onAction event to signInClicked method 
image::images/fig_8_01.png[]

If you run the `Main` program and click three times on the button Sign In, the console will print the hello message three times as shown on Figure 8-2.

[[FIG8-2]]
.After clicking 3 times on Sign In button 
image::images/fig_8_02.png[]

So there is a link between the GUI and the controller. If we had several buttons on the GUI, we could either map each of them to a separate method in controller, or have one method, which could recognize which button was clicked. The controller will invoke your event handler providing the `ActionEvent` object as an argument. Its property `target` identifies, well the target of the event, which is a Sign In button in our case. 

I ran our application in the debug mode just to show you that the `target` property on the `ActionEvent` correctly recognizes the event target shown in Figure 8-3.   

[[FIG8-3]]
.Viewing properties of ActionEvent in debugger 
image::images/fig_8_03.png[]

There is another event property `source`, which has the same value as `target` in our application. There are cases when `source` and `target` are different because an event travels through all containers until it reaches the target. So if a component is nested inside a container would be located in. This is an advanced topic, but I still want to give you an illustration. 

When you want to handle button clicks, you don't really care in which area inside the button was the mouse pointer when the user clicked on the button. So handing `ActionEvent` was sufficient. But there is another event called `MouseEvent`, which gives you more details on the click event. 

In your signin.fxml you're allowed to use `onMouseClicked` instead of `onAction` for the button. But if you do so, the `Button` will be considered a container for a special skin class `LabeledText` with the text _Sign In_, and if you click on the words _Sign In_ the source of the event will be `Button`, and the target would be the class `LabeledSkin`. I've created an event handler `signInMouseClicked` and ran it through a debugger. Now the source and target of the event are different.

[[FIG8-4]]
.Viewing properties of MouseEvent in debugger 
image::images/fig_8_04.png[]

==== Data Exchange Between GUI Components And Controller

No that we know how to link controller's event handlers to FXML components, the next question is how to read/write data from/to these components. In case of Sign In application we need to know what ID/Password the user entered and update the GUI from the controller accordingly.

To read the values from GUI components we'll need to give them unique id's in the FXML file. We don't need to give id's to all component - only to those that have values for handling. Take a look at the `<childrens>` section of signin.fxml:

[source, xml]
----
<children>
   <Label alignment="CENTER" text="User ID:" />
   <Label text="Password:"  styleClass="bluelabel" GridPane.rowIndex="1" />
   <Button id="submitBtn" mnemonicParsing="false" prefWidth="300.0" text="Sign In"
           GridPane.columnSpan="2" GridPane.rowIndex="2"
           onAction="#signInClicked"/>
   <TextField GridPane.columnIndex="1" fx:id="id" />
   <PasswordField GridPane.columnIndex="1" GridPane.rowIndex="1" fx:id="pwd"/>
</children>
----

Only the `TextField` and `PasswordField` have an attribute `fx:id` - this is how we can assign id's in fxml.

The next step is to inject them into the variables in the `signin.Controller` class. The following code fragment shows how to inject component references into the `id` and `pwd` fields. This is how I'll declared two Java variables in the `Controller` clas with the names that match those from signin.fxml:

[source, java]
----
@FXML private TextField id;

@FXML private PasswordField pwd;
----

Java has so called annotations (not covered in this book). They start with `@` sign and can be placed in front of the variable, class, or a method declaration depending on how  the annotation was defined. Some annotations are used by Java compiler, and some by the JVM. The JavaFX annotation `@FXML` instructs runtime to inject the references to the specifies GUI objects into the variables. 

In other words, JavaFX runtime will read the first line as follows: "I need to get the object that I created after loading signin.fxml file, and then inside this object find the component with an the `fx:id="id"`. Finally, I need to insert the reference to this component into the Java variable `id`". The same applies to the variable `pwd`.

The rest is easy. Just use the injected values in you event handler. The code of our `Controller` is shown next. Its method `signInClicked` checks the value entered in the User ID field in the GUI, and if it's not equal to "Yakov", then the code sets the background of the GUI component to pink color.

[source, java]
----
public class Controller {

  @FXML private TextField id;            //  <1>

  @FXML private PasswordField pwd;       //  <1>

  public void signInClicked(ActionEvent evt){

    String userID = id.getText();      //   <2> 
    String password = pwd.getText();   //   <2>

    if (!"Yakov".equals(userID)){      //    <3>
      id.setStyle("-fx-background-color:lightpink;"); //<4>
    } else{
      id.setStyle("-fx-background-color:white;");    // <5>
    }

    System.out.println("got id:" + userID + ", got password: " + password);

    System.out.println("Hello from signInClicked method in controller");
  }
}
----

<1> Inject the references to GUI components into member variables.  
<2>  Extract the text from the GUI objects 
<3>  Has the user not entered Yakov in the User ID field? We use the negation operator ! here.
<4>  Set the background color to `lightpink` if the entered user id is not Yakov. You can find major CSS color names at http://docs.oracle.com/javafx/2/api/javafx/scene/doc-files/cssref.html   
<5>  Set the background color to back to `white` if the entered user id is not Yakov. 

If you run the `Main` program and enter the wrong user id, the window will look as follows:

[[FIG8-5]]
.After entering the wrong user id 
image::images/fig_8_05.png[]


=== Assigning Event Handlers in Java

If your program is written completely in Java without any use of FXML, you'll be assigning event handlers using so called http://docs.oracle.com/javafx/2/events/convenience_methods.htm[convenience methods] that have names that start with `setOn` like `setOnAction`, `setOnKeyTyped`, `setOnEditStart` etc. Each of the GUI components has has several of such methods.   

You can provide event handling code to the convenience methods using anonymous classes, lambda expressions, or method references (not covered in this book). Implementing event handlers as lambda expressions as they are easier to write. Typically, you'll be writing code to react if some event has happened. For example, if you have a button represented by a variable `myButton` you can write an event handler for the click event:

[source, java]
----
Button signInButton = new Button("Sign In");
signInButton.setOnAction(evt -> 
    System.out.println("The Sign In button was clicked.")
);
----

You've got introduced lambda expressions in Chapter 5. The above code snippet means that lambda expression gets the event object as an argument, but don't really uses its values but just prints the message that the button was clicked. 

What's the type of the `evt` argument? Java compiler will figure it out automatically. Since the method `setOnAction` expects to get the `ActionEvent` object from the JVM, compiler guesses that the type of the `evt` is `ActionEvent` so you don't even need to write it in the program code. You've seen a similar example of of type inference in Chapter 5.  

To bring all pieces of the puzzle together, I'll show you another version of the Sign In application that will look the same, but won't use FXML - everything will be programmed in Java. The following class `MainPureJava` and `signin.css` is all we need for programming the functionality of our Sign In window. There is not need to use `signin.fxml` or `Controller.java` in this case. 

[source, java]
----
package signin;

import javafx.application.Application;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.*;

public class MainPureJava extends Application {

  public void start(Stage primaryStage) {

    final int TWO_COLUMN_SPAN = 2;               // <1>

    Label userIdLbl = new Label("User ID:");     // <2> 
    TextField userIdTxt = new TextField();
    Label userPwdLbl = new Label("Password:");
    userPwdLbl.getStyleClass().add("bluelabel");
    PasswordField userPwdTxt = new PasswordField();

    GridPane root = new GridPane();              //  <3> 
    root.setVgap(20);
    root.setPadding(new Insets(10));
    root.setAlignment(Pos.CENTER);
    root.setId("root");

    // Setting constraints for firs 2 rows
    GridPane.setConstraints(userIdLbl, 0, 0);    //  <4>
    GridPane.setConstraints(userIdTxt, 1, 0);
    GridPane.setConstraints(userPwdLbl, 0, 1);
    GridPane.setConstraints(userPwdTxt, 1, 1);

    root.getChildren().addAll(userIdLbl, userIdTxt, 
    userPwdLbl, userPwdTxt);                      //  <5>


    Button signInBtn = new Button ("Sign In");    //  <6>
    signInBtn.setId("submitBtn");  // used in CSS

    // Event handler with lambda expression
    signInBtn.setOnAction(evt -> {                 //  <7> 

        String userID = userIdTxt.getText();
        String password = userPwdTxt.getText();
        if (!"Yakov".equals(userID)){
            userIdTxt.setStyle("-fx-background-color: lightpink;");
        } else{
            userIdTxt.setStyle("-fx-background-color: white;");
        }

        System.out.println("Got id " + userID +
                           " and password " + password);
    });

    // Allow the button to be wider
    signInBtn.setPrefWidth(Double.MAX_VALUE); 

    // Adding a wide button to the third row
    root.add(signInBtn,0,2,TWO_COLUMN_SPAN,1);     

    Scene scene = new Scene(root,250,180);
    scene.getStylesheets()                         // <8>
         .add(getClass()
         .getResource("signin.css")              
         .toExternalForm());
    
    primaryStage.setScene(scene);                  // <9>
    primaryStage.show();
  }

  public static void main(String[] args) {
      launch(args);
  }
}
----

<1> This programs uses the `GridPane` layout with three rows and two column. Since the Sign In button will span tho columns, I declared a final variable `TWO_COLUMN_SPAN` that will be used when the button will be added to the grid. 
<2> Then I instantiate labels and text fields.

<3> After that I create an instance of the `GridPane` container.

<4> To add the labels and text fields to the proper cells of the first two rows of the grid, I set the constraints on the `GridPane` object.

<5> The GUI components for the first two rows are instantiated, constraints are set so I add them as children to the root of the _scene graph_ - the `GridPane`.

<6> Now I create the instance if the Sign In button and assign the id to it. This was explained in the Styling with CSS section in Chapter 7.

<7> The lambda expression implements the application logic to be invoked as a reaction to the `ActionEvent`.    

<8> The we create a scene object an apply the CSS to it. This is probably the first time you see the method chaining. All these lines that starts with dots are methods chained together - all of them are sequentially invoked on the scene object. 

<9> Finally, the scene is added to the stage and the curtain goes up.

Some programmers like GUI designer tools where they can drag and drop components. Some prefer writing Java code. I prefer working with FXML, because it greatly simplifies  design of the complex windows. Besides separating the design from the application logic is also a good idea because a person who doesn't know programming can master Scene Builder and create nice GUI layouts allowing programmers to take care of application logic.


==== Further Reading on Event Handling

I've explained you the basics of event handling using the `ActionEvent` and `onAction` event handler as an example. Some other examples of the events are:`KeyEvent` (e.g. the user pressed a key on the keyboard), `MouseEvent`(e.g. the user pressed the mouse key and we need to know coordinates of the mouse pointer), `TouchEvent` (e.g. the user touched the screen), `WindowEvent` (e.g. the user is about to close the window) et al. For more detailed explanation of JavaFX events visit Oracle's tutorial about handling events at http://docs.oracle.com/javafx/2/events/jfxpub-events.htm.

=== Data Binding and Properties

JavaFX has an interface `Property` located in the package `javafx.beans.property`, which defines a very useful functionality allowing to _bind_ the GUI components with properties of other Java objects. If a property on a Java object changes, the new value will be automatically reflected on the appropriate GUI component and visa versa. Bi-directional binding is available too, so no matter what changes - the GUI or the Java object - the other party will be immediately notified.

Imagine that you're developing a multi-player game that has a Java object receiving the moves of other gamers from a central server. When a Java object receives a new move, you need to modify the content of the corresponding GUI component of the game. With JavaFX you can simply bind a property of a Java class that stores player's moves (e.g. `playersMove`) to the property of, say a `Label` component on the GUI. No more coding required. As soon as the `playersMove` value changes, the `Label` will be automatically updated.  JavaFX properties greatly simplify the process of synchronization of the data and the GUI.

Existing implementations of the `Property` interface add  the change notification functionality to regular class attributes. The interface `Property` declares the following methods: `bind`, `unbind`, `bindBidirectional` , `unbindBidirctional`, and `isBound`. You can bind to a JavaFX property only the value of an `ObservableValue` type, which is explained in the sidebar. 

.Design Patterns Briefly
****************************
Over the years software developers came up with a number of _design patterns_, which have names and descriptions of how to program certain scenarios. Programmers casually use design pattern names in their conversations and technical literature. For example, one programmer can say to another , "You'd better implement MVC in this program", and both understand what this means. Let me explain you briefly a couple of design patterns - MVC and Observer - so you'll be a little better prepared for chatting with programmers.

*MVC* stands for Mode View Controller. This design patter recommends separating the code that stores application data (Model) from the code implementing the user interface (View) and from the code that controls the data exchange and implements application logic (Controller). As a matter of fact we've almost implemented MVC in one of the versions of the Sign In application. The file _signin.fxml_ was a view, and the class `signin.Controller` played a role of a controller. Since this example had just two variables (`id` and `pwd`) we didn't created a special model class for them.

*Observer* design pattern is used to implement scenarios when one object, a.k.a. the observer needs to watch changes in other object(s), the observables. For example, if a Twitter user (the observable) posts a twit all of his followers (observers) will get notified. If a programming language or a library supports data binding, implementing the observer design pattern becomes pretty easy, which you'll see in this chapter. 

If you're interested in detailed coverage of design patters, get the book "Head First Design Patterns" published by O'Reilly Media. 
****************************

Classes that implement `Property` interface are located in the package `javafx.beans.property`. For each property type there are two classes: one that allows only reading property values and the other one for read and writing (changing the values). For example, if you need a `String` property, use either `ReadOnlyStringWrapper` or `SimpleStringProperty`. Similarly named classes exist for other data types and some collections too.

As we always do in this book, let's learn by coding. I'll continue adding features to our Sign In application. This time I'll add a `Label` component with `fx:id="errMsg"` to the view in FXML file to display sign in error messages if any. In the controller class I'll add a corresponding variable `errMsg` and will inject a reference to the `Label` into this variable. 

The next step is to declare a bindable property `signinError` in the class `Controller` that will get the value of the error message if any. But since a regular `String` can't be bindable, we'll use the data type `SimpleStringProperty`  

Finally, I'll bind the label and the variable to insure that an error message is immediately displayed on the screen as soon as its value changes. 

Let's place an additional `Label` component at the bottom of the Sign In window. I'll add another row to the `GridPane` and place there a `Label` that will span two columns. This label will have `fx:id="errMsg"` and initially won't  have any text - it'll be invisible. The `<children>` section of the FXML file will look as follows:

[source, xml]
----
<children>
      <Label alignment="CENTER" text="User ID:" />
      <TextField GridPane.columnIndex="1"  fx:id="id" />
      <Label text="Password:"  styleClass="bluelabel" GridPane.rowIndex="1" />
      <PasswordField GridPane.columnIndex="1" GridPane.rowIndex="1" fx:id="pwd"/>
      <Button id="submitBtn" mnemonicParsing="false" prefWidth="300.0" text="Sign In"
              GridPane.columnSpan="2" GridPane.rowIndex="2"
              onAction="#signInClicked"/>
       <Label alignment="CENTER" GridPane.rowIndex="3"
              GridPane.columnSpan="2" prefWidth="300.0" fx:id="errMsg"/>
   </children>
----

Injecting a reference of the new label into controller and declaring a property to store the error message will look like this:

[source, java]
----
@FXML private Label errMsg;

SimpleStringProperty signinError = 
                        new SimpleStringProperty();
---- 

The next question is when and where do the binding? If I'd be creating an instance of the `Controller` with the `new` operator I could have done it in the class constructor after the GUI component are created. But JavaFX runtime instantiates the `Controller` for us, so how can we catch the moment when the GUI components are ready? 

Luckily, Java comes with a handy annotation `@PostConstruct` defined in the package `javax.annotation`. This annotation is a part of a library called Context Dependency Injection (CDI). In CDI you can place the annotation `@PostConstruct` in front of any method declaration to request that this method must be called right after the object is constructor. In JavaFX there is a small restriction - such a method must be called `initialize`. 

[source, java]
----
@PostConstruct
public void initialize() {

  errMsg.textProperty().bind(signinError);
}
----

JavaFX properties are observables. So you can read the above the above code as follows: "I want the text property of the label `errMsg` to be the observer (a.k.a. listener) to the property `signinError` (observable). So whenever `signinError` changes, the text property of the label will get the latest value. 

To complete the binding Sign In example, the event handler for the Sign In button should not only paint the wronn ID in light pink, but also modify the value of the `signinError` property. The complete code of the class `BindableController` is shown next.  

[source, java]
----
public class BindingController {

    @FXML
    private TextField id;

    @FXML
    private PasswordField pwd;

    @FXML private Label errMsg;

    SimpleStringProperty signinError = new SimpleStringProperty();

    @PostConstruct
    public void initialize() {
        System.out.println("Controller's ready. Let's bind some components");

        errMsg.textProperty().bind(signinError);
    }

    public void signInClicked(ActionEvent evt){

        String userID = id.getText();
        String password = pwd.getText();
        if (!"Yakov".equals(userID)){
            id.setStyle("-fx-background-color: lightpink;");
            signinError.set("Wrong id:" + userID);

        } else{
            id.setStyle("-fx-background-color: white;");
            signinError.set("");
        }

        System.out.println("got id:" + userID + ", got password: " + password);

        System.out.println("Hello from signInClicked method in controller");
    }
}
----

Note that in the if statement I set the error message when the ID is wrong, and reset the `signinError` to an empty string when the ID is correct. After I ran the Sign In application the above controller, entered Alex as the user ID and clicked the button Sign In, my window looked like this:

[[FIG8-6]]
.Binding in action after entering the wrong user id 
image::images/fig_8_06.png[]

Enter the right user ID, click on Sign In again, and the binding mechanism will remove the error message from the window.

=== Deploying With JavaFX Packager

http://docs.oracle.com/javafx/2/deployment/jfxpub-deployment.htm.

The `Application` class has a method `getParameters`, which is a JavaFX way of getting command line arguments that might be passed to your application during its launch .

I'm sure many of you want to know if it's possible to use JavaFX for writing applications for smart phones. Oracle doesn't offer the JavaFX libraries for mobile platforms, but it's still possible. 

To develop JavaFX applications for iOS, you'd need to install and learn on your own some additional software, namely RoboVM[http://www.robovm.com/] is an SDK for converting Java bytecode into a native device code as if it was written in C programming language, which makes it deployable on iOS devices. 

There is also a community site JavaFX Ports[ http://javafxports.org/page/home] where people are working on deployment of JavaFX applications on iOS and Android devices.

=== The First Look at Multi-Threading 

So far, all our programs perform actions in a sequence – one after another. If a program calls two methods, the second method waits until the first one completes. In other words, such a program has only one _thread of execution_.

In a real life though, we can do several things inn parallel like eat, talk on the phone, watch TV, and do the homework. To do all these actions in parallel we use several "processors":  hands, eyes, and mouth. 

Today, only your grandma's computer might have a single processor (a.k.a. Central Processing Unit or CPU). But most likely your computer has at least two CPU's and a GPU for graphics processing. A CPU performs calculations, sends commands to the monitor, hard disk or solid state drive, remote computers on the Internet, and so on. 

But even a single processor can perform several actions at once if a program uses _multiple threads_. One Java class can start several threads of execution that will take turns in getting slices of the processor’s time. 

A good example of a program that creates multiple threads is a Web browser. For instance, you can browse the Internet while downloading some files so one program (the browser) runs two threads of execution in parallel. 

JavaFX also runs more than one thread. Imagine a program with a GUI that's constantly is being updated based on the intensive calculations. It could be a game with multiple moving characters, balls, squares or other shapes. It could be an application for a TV channel that shows a video, a running commercial, viewers polls and more. It could be a business application that displays several pieces of constantly changing information in different parts of the window. 

Updates of the GUI in JavaFX are done in a so called  application thread. The idea is to separate intensive calculations from the GUI updates. Say, the user pressed the button Play on JavaFX video portal application like Netflix. If the requests for the remote video and actual playing of the video (GUI updates) would be done in the same application thread, the video would be choppy every time there was a delay in getting content. The screen would be "frozen" and the user wouldn't be able to use any screen components.

I'd better see it to believe it, right? I can easily demonstrate you a "frozen GUI" effect by making a small change in the class `signin.Controller` in our Sign In application. The simplest way to emulate a long running process is to place the the executing thread to sleep.

Hence the long running processes shouldn't be running on the application thread, but have a dedicated one. The application thread should be mainly updating the GUI, and not running long processes. All requests for the scene updates have to be placed into a special event queue in the application thread.  

The method `runLater` defined in the class `Platform` places the `Runnable` object into an event queue.

In the chapter on Ping-Pong game I'll show you how your program can creates multiple threads too. One thread will be responsible for displaying the table, while the other one  will calculate coordinates of the ball and paddles and will send commands to the first thread to repaint the window. 

To be continued...


=== What to Study Next About JavaFX

In Chapter 7 and 8 I gave you a very brief introduction to JavaFX. You'll be writing  more of JavaFX code while working on the Tic-Tac-Toe and Ping-Pong games, but JavaFX has lots of interesting features that you may want to explore on your own. JavaFX has more than 60 GUI components, so try to play with them. Also, JavaFX allows you to integrate audio and video in your application, create special effects and transitions to make your programs as cool and entertaining as you want them to be. You may find some interesting capabilities by researching classes located in the package `javafx.animation`.

Pick up a book on JavaFX 8 or later and experiment on your own. One of the better books on the subject is "Pro JavaFX 8: A Definite Guide to Building Desktop, Mobile, and Embedded Java Clients" published by Apress. 


=== Project 
